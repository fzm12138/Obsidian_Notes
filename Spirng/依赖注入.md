### Spring 由三种依赖注入方式
- 基于属性(filed)注入
	- 在bean的变量上进行依赖注入
	- 本质上是通过反射的方式直接注入到 field
```Java
@Autowired
UserService userService;
```

- 基于set方法注入
	- 通过对应变量的setXXX()方法上使用注解
```java
private UserService userService;
 
@Autowired
public void setUserService(UserService userService) {
    this.userService = userService;
}
//说明：在 Spring 4.5 及更高的版本中，setXXX 上面的 @Autowired 注解是可以不写的。
```

- 基于构造器注入
	- 将各个必须的依赖全部放在带有注解构造方法的参数中
	- 并在构造方法中完成对应变量的初始化
```java
private final UserService userService;
 
@Autowired
public UserController(UserService userService) {
    this.userService = userService;
}
```

#### 属性注入简洁但是有问题
##### NO.1
```java
@Autowired
private UserService userService;
 
private String company;
 
public UserServiceImpl() {
    this.company = userService.getCompany();
}
```
- 编译的时候不报错，运行空指针
Java初始化一个类时，按照 静态变量/静态语句块->实例变量/初始化语句块->构造方法->@Autowired顺序
- 故执行这个类的构造方法时，user对象尚未注入

##### NO.2
- 不能有效地指名依赖
- 常见bug：
	- 依赖注入的对象为null
	- 启动依赖容器时遇到这个问题是配置的依赖少了注解
	- 这种方式过于依赖注入容器
	- 没有启动整个依赖容器时，此类不能运转，反射时无法提供这个类需要的依赖
##### NO.3
- 依赖注入的核心是容器管理的类不应该依赖被容器管理的依赖
- 如果此类使用了依赖注入的类，那么这个类摆脱这几个依赖也能正常运行
- 变量注入保证不了上述特点
#### Solution:
