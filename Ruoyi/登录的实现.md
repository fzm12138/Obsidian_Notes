*@Author fzm*
前端会检验是否“记住密码”
- 如果记住密码会存入cookie 

### **uuid 用户名和密码传入后端会做三件事**
  *公平！公平！还是他妈的公平*
  - 检验验证码
  - 校验用户名与密码
  - 生成token
这三步被封装成了一个方法
```java
public String login(String username, String password, String code, String uuid)  
{
///-------------------------------
	
}
```
校验验证码
```java
/**  
* 校验验证码  
*  
* @param username 用户名  
* @param code 验证码  
* @param uuid 唯一标识  
* @return 结果  
*/  
public void validateCaptcha(String username, String code, String uuid)  
{  
boolean captchaEnabled = configService.selectCaptchaEnabled();  
if (captchaEnabled)  
{  
String verifyKey = CacheConstants.CAPTCHA_CODE_KEY + StringUtils.nvl(uuid, "");  
String captcha = redisCache.getCacheObject(verifyKey);  
redisCache.deleteObject(verifyKey);  
if (captcha == null)  
{  
AsyncManager.me().execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_FAIL, MessageUtils.message("user.jcaptcha.expire")));  
throw new CaptchaExpireException();  
}  
if (!code.equalsIgnoreCase(captcha))  
{  
AsyncManager.me().execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_FAIL, MessageUtils.message("user.jcaptcha.error")));  
throw new CaptchaException();  
}  
}  
}
```

```java
//异步记录日志 提供了一个线程池，将任务提交给线程池处理，从而与其他功能进行异步处理
//用工厂方法生成了一个记录日志的任务，日志是验证码失效，任务存储任务信息，将任务扔进线程池
AsyncManager.me().execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_FAIL, MessageUtils.message("user.jcaptcha.expire")));
```

登录生成toke的实现
```java
public String createToke(LoginUser loginUser){
String token =IdUtils.fastUUID();
//token生成
loginUser.setToken(token);
setUserAgent(loginUser);
refreshToken(loginUser);

Map<String,Object> claims = new HashMap<>();
claims.put(Constants.LOGIN_USER_KEY,token);
return createToken(claims);
}
```

```java
private String createToken(Map<String, Object> claims)  
{  
String token = Jwts.builder()  
.setClaims(claims)  
.signWith(SignatureAlgorithm.HS512, secret).compact();  
return token;  
}
```
JWTs
- JSON Web Token(JWT)基于token验证的方案
- token编码算法，server根据密码和算法生成token，发给user；user之后每次请求都在http header里加上这个token；
- server检查这个token是否合法，是否过期，并解析出subject和claim里的data
- JWT中的data是base64编码的，没加密，不要放入敏感数据
```java
base64url_encode(header) + '.' + base64url_encode(payload) + '.' + signature
/**
 1）[header](https://so.csdn.net/so/search?q=header&spm=1001.2101.3001.7020)：  使用算法说明，如：`{"alg":"HS512"}`  
 2）payload：json格式的数据载体，如：`{"userName":"jacky","userId":121,"exp":1665934899}`  
3）signature：数据签名字符串
*/
```
**实际加密的过程：**
1.  header内容base64
2.  payload内容base64
3.  把上面两个拼接起来加上秘钥secret后，通过算法加密得到签名字符串signature

JWT只通过算法实现对Token合法性的验证，不依赖数据库，Memcached的等存储系统，因此可以做到跨服务器验证，只要密钥和算法相同，不同服务器程序生成的Token可以互相验证。

退出登录， 只要客户端端把Token丢弃就可以了，服务器端不需要废弃Token

服务器端提供刷新Token的接口， 客户端负责按一定的逻辑刷新服务器Token

REST API是无状态的，意味着服务器端每次请求都是独立的，即不依赖以前请求的结果，因此也不应该依赖JWT token做业务查询， 应该在请求报文中单独加个userid 字段。

为了做用户水平越权的检查，可以在业务层判断传入的userid和从JWT token中解析出的userid是否一致， 有些业务可能会允许查不同用户的数据

```js
return new Promise((resolve,reject)=>{
	login(username,password,code,uuid).then(res=>{
		//在这里保存了令牌
		setToken(res.token)
		commit('SET_TOKEN',RES.TOKEN)
		resolve()
		})............
})
```
-------
实际是loginService.login生成了token返回给前端,前端在Promise这里保存了令牌














